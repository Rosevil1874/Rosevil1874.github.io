<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[24 - 交换相邻结点]]></title>
    <url>%2F2018%2F04%2F11%2F24.%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述 解法一 将链表遍历一遍取出value值； 按相邻节点（奇偶下标）交换的顺序连接起来。虽然方法很蠢，但是过了哈哈哈哈1234567891011121314151617181920212223242526272829303132333435363738# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ lists = [] while head: lists.append(head.val) head = head.next for i in range( 0, len(lists), 2 ): if i + 1 &lt; len(lists): lists[i], lists[i+1] = lists[i+1], lists[i] h = ListNode(0) node = h for i in range(len(lists)): node.next = ListNode(lists[i]) node = node.next return h.next head = ListNode(1)node = headfor i in range(4): node.next = ListNode(i+2) node = node.nexts = Solution()r = s.swapPairs(head)while r: print(r.val) r = r.next 解法二 加个dummy结点指向头结点； 每隔一个结点原地交换一下；12345678910111213141516171819class Solution: def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ lists = [] dummy = ListNode(0) dummy.next = head prev = dummy cur = head while cur and cur.next: prev.next = cur.next cur.next = cur.next.next prev.next.next = cur prev = cur cur = cur.next return dummy.next 解法三递归~~~还不太懂123456789101112class Solution: def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if head == None or head.next == None: return head tmp = head.next head.next = swapPairs(tmp.next) tmp.next = head return tmp]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23 - 合并K个元素的有序链表]]></title>
    <url>%2F2018%2F04%2F11%2F23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述 审题：首先吧，这个题目我就没看懂，合并有序链表并返回有序链表，excuse me？？然后吧，看了一下输入输出type，索德斯呢~~ k个链表都是有序的，合并成一个/摊手最后吧，想起来之前做过一个合并俩有序链表的,传送门。当时最简洁的方法是使用了递归，现在是K个链表的话，一个个连铁定超时没得跑的。怎么办呢，偷偷瞟一眼相关话题，有堆和分治算法。哎，第一反应就是把算法书翻出来再学一遍，虽然前面已经几乎两遍了，算法助教说的果然没错，这本书是值得花时间的。 分治算法 对半划分直到只有一个或两个链表； 使用合并两个有序链表的方法合并。以4链表为例： 1、3合并，合并结果放到1的位置； 2、4合并，合并结果放到2的位置； 再把1、2合并（相当于原来的13 和 24合并）。12345678910111213141516171819202122232425262728293031323334# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ l = len(lists) if l == 0: return None while l &gt; 1: k = (l + 1) // 2 for i in range(l // 2): lists[i] = mergeTwoLists(lists[i], lists[i + k]) l = k return lists[0] def mergeTwoLists(self, l1, l2): if not l1: return l2 elif not l2: return l1 else: if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 递归深度超限了orz,Python中默认的最大递归深度是989，当尝试递归第990时便出现递归深度超限的错误: 虽然可以手动设置递归调用深度：12import syssys.setrecursionlimit(10000000) 但是我不要，我！不！要!/傲娇脸应该是合并两个链表也是递归，所以就好多好多递归所以超了吧。把合并两个数组改一下：12345678910111213141516def mergeTwoLists(self, l1, l2): head = ListNode(0) res = head while l1 and l2: if l1.val &lt; l2.val: res.next = l1 l1 = l1.next else: res.next = l2 l2 = l2.next res = res.next if l1: res.next = l1 elif l2: res.next = l2 return head.next 果然通过了哗哈哈哈哈哈哈哈哈哈哈哈✧*｡٩(ˊᗜˋ)و✧｡ 最小堆 把k个链表的首元素加入最小堆中，使其升序排列； 每次取出堆顶元素（最小）加入结果链表，然后将其后那个元素加入最小堆； 直到把堆取空了，结果链表就合并完成了。 but…python没有实现堆这样的数据结构呀，计几构建吧。哈哈哈，下次吧嘻嘻12]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22 - 括号生成]]></title>
    <url>%2F2018%2F04%2F11%2F22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[题目描述 审题：看到括号生成不自觉会想到括号匹配的检查，在生成过程中也要注意匹配规范。 回溯法cr:leetcode-22-生成括号 定义：回溯法是一个类似枚举的搜索尝试过程，主要是在搜索过程中寻找问题的解，当发现不满足求解条件时，就回溯返回，尝试别的路径。 回溯与递归：回溯指的是一种此路不通，绕道迂回的算法思想，递归是代码层次上的一种组织结构。 回到此题中来，下图可以说是非常直观了。这个选择过程就是一种树结构。最开始的时候肯定只能选 (，因此，分析是从 ( 开始的。 私以为以下代码可以说是超级棒了12345678910111213141516171819class Solution: def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ res = [] self.helper( '', res, n, 0, 0) return res def helper(self, curr, res, n, left, right): # 当 右括号 = n 时已经找到一个结果 if right == n: res.append(curr) if left &lt; n: self.helper(curr+'(',res, n, left+1, right) if left &gt; right: self.helper(curr+')',res, n, left, right+1)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16 - 最接近的三数之和]]></title>
    <url>%2F2018%2F04%2F10%2F16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 审题：看到题目的我，悄悄点开了旁边的相关话题，恩又有双指针，大概知道怎么做了hiahia＼＼\٩(‘ω’)و//／／三数之和-传送门 方法[类似三数之和] 将数组排序； 第一层循环遍历元素； 第二层循环使用双指针向中间靠拢检查； 遇到更符合条件的更新结果。 123456789101112131415161718192021class Solution: def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() closest = nums[0] + nums[1] + nums[2] for i in range(len(nums)): j, k = i + 1, len(nums) - 1 while j &lt; k: value = nums[i] + nums[j] + nums[k] closest = value if abs(target - value) &lt; abs(target - closest) else closest if value == target: return target elif value &gt; target: k -= 1 else: j += 1 return closest]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15 - 三数之和]]></title>
    <url>%2F2018%2F04%2F10%2F15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 审题：这个这个，似曾相识呀，诶不就是第一题两数之和嘛两数之和-传送门So，可不可以把“三数之和”问题改成“两数之和+X”捏。。。 方法一：利用“两数之和” 计算将列表中每个数与几（target）相加的和为零； 分别使用这个target作为两数之和问题中的target； 去重之后将符合条件的结果加入返回数组。12345678910111213141516171819202122class Solution: def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ l = len(nums) ret = [] for j in range(l): target = 0 - nums[j] tmp = &#123;&#125; for i, a in enumerate(nums): if i == j: continue if target-a in tmp: re = sorted( [nums[j], nums[tmp[target-a]], nums[i]] ) if re not in ret: ret.append( re ) else: tmp[a] = i return ret 超时啦啊啊啊啊啊(눈‸눈) 方法二：双指针 将数组排序； 第一层循环遍历元素到倒数第三个； 第二层循环使用双指针向中间靠拢检查； 符合条件且不重复的加入结果数组。 12345678910111213141516171819202122232425262728293031323334class Solution: def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; l = len(nums) nums.sort() ret = [] for i in range(l - 2): # 去重 if i &gt; 0 and nums[i] == nums[i-1]: continue # 双指针归位！ j, k = i + 1, l - 1 while j &lt; k: if nums[i] + nums[j] + nums[k] == 0: ret.append( [nums[i], nums[j], nums[k]] ) j += 1 k -= 1 # 去重 while j &lt; k and nums[j] == nums[j-1] : j += 1 while j &lt; k and nums[k] == nums[k+1] : k -= 1 elif nums[i] + nums[j] + nums[k] &lt; 0: j += 1 else: k -= 1 return ret 还是超时，黑人问号.jpg 问题出在哪里，，，我把l = len(nums)去掉了，所有需要用到l的地方直接使用len(nums)就AC了，excuse me？？？把它暂存起来不是更快吗？？？看看这个卡住的测试用例吧：]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['LeetCode小记']]></title>
    <url>%2F2018%2F04%2F10%2FLeetCode%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[没咋弄懂的 两个排序数组的中位数 → 戳 最长回文子串 → 戳 正则表达式匹配 → 戳 整数转罗马数字 → 戳 罗马数字转整数 → 戳 三数之和 → 三数之和-传送门 合并K个元素的有序链表 → 戳 交换相邻结点 → 戳]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14 - 最长公共前缀]]></title>
    <url>%2F2018%2F04%2F10%2F14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目描述 审题：多么简单粗暴的题目啊 方法思路： 找出最短的字符串，以其为基准； 遍历最短字符串的每个字符，同时检查其他每个字符串的当前位置字符； 若不相等，返回最长前缀； 若相等，最长前缀更新：加上当前字符。 12345678910111213141516171819202122class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ strs_l = len(strs) if strs_l == 0: return '' pre = '' min_l = len(strs[0]) for i in range(1, strs_l): min_l = min(min_l, len(strs[i])) for i in range(min_l): x = strs[0][i] for j in range(strs_l): if strs[j][i] != x : return pre pre += x return pre]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11 - 盛最多水的容器]]></title>
    <url>%2F2018%2F04%2F10%2F11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述 审题：这个题目从字面意思上理解还是不太直观的，在纸上画画图就一目了然了。懒得慢慢画个好看的图，去人家的文章里找找，找到啦，还是个动图啊厉害厉害，不过这个图直接泄露了解题方法啊~~ 方法思路【这个和CCF有一题‘最大的矩形’异曲同工啊】： 要装最多水，就要矩形面积最大； 以短边作为计算高度，木桶效应嘛( ･´ω`･ )； 从最大宽度开始，即双指针从两端向中间遍历； 每次更新最大面积，指针相遇时返回结果。 123456789101112131415161718192021222324class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ l = len(height) maxArea = 0 area = 0 i = 0 j = l - 1 while i &lt; j: if height[i] &lt; height[j]: h = height[i] area = (j - i) * h i += 1 else: h = height[j] area = (j - i) * h j -= 1 maxArea = max(maxArea, area) return maxArea 新技能get没有思路的时候，可以悄悄点开这个相关话题，下面列出来的点一般就是解题方法啊哈哈哈，我可真聪明(〃ﾉωﾉ)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 - 正则表达式匹配]]></title>
    <url>%2F2018%2F04%2F09%2F10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[此题有待深究 哦哦哦 题目描述 自己的思路： 由于*控制的是其前面字符的匹配，因此可以由正则表达式的末尾开始检查； 没了。。没了。。。直接用字符串的方法肯定是不行的，越想越复杂。。 ↓↓别人的思路 If you are stuck, recursion is your friend. 递归 cr:[LeetCode] Regular Expression Matching 正则表达式匹配 这个代码还没调通，递归调用函数出错，作用域问题 1234567891011121314151617181920212223242526272829303132class Solution: def isMatch(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: bool &quot;&quot;&quot; s_len = len(s) p_len = len(p) if s_len == 0 and p_len == 0: return False if s_len == 1 and p_len == 1: if s[0] == p[0] or p[0] == &apos;.&apos;: return True else: return False if p[1] != &apos;*&apos;: if s_len == 0: return False if s[0] == p[0] or p[0] == &apos;.&apos;: return isMatch(self, s[1:], p[1:]) else: return False while len(s) and (s[0] == p[0] or p[0] == &apos;.&apos;): if isMatch(self, s, p[2:]): return True s = s[1:] return isMatch(self, s, p[2:]) 动态规划 cr:leetcode 10 Regular Expression Matching This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are:a. P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’);b. P[i][j] = P[i][j - 2], if p[j - 1] == ‘’ and the pattern repeats for 0 times;c. P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times.Putting these together, we will have the following code. 12345678910111213141516171819202122232425class Solution: def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ s_len = len(s) p_len = len(p) dp = [[True] + [False] * s_len] for i in range(p_len): dp.append([False]*(s_len+1)) for i in range(1, p_len + 1): x = p[i-1] if x == '*' and i &gt; 1: dp[i][0] = dp[i-2][0] for j in range(1, s_len+1): if x == '*': dp[i][j] = dp[i-2][j] or dp[i-1][j] or (dp[i-1][j-1] and p[i-2] == s[j-1]) or (dp[i][j-1] and p[i-2]=='.') elif x == '.' or x == s[j-1]: dp[i][j] = dp[i-1][j-1] return dp[p_len][s_len] 使用第三方库re一行代码/微笑脸12345import reclass Solution: def isMatch(self, s, p): return re.match('^' + p + '$', s) != None]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8 - 字符串转整数]]></title>
    <url>%2F2018%2F04%2F09%2F8.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 方法 嗯要注意的地方题目上已经说得非常明白了，一个一个care就好啦。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def myAtoi(self, str): """ :type str: str :rtype: int """ l = len(str) ret = 0 is_valid = False # 是否无效， flag = 1 # 1：正数，-1：负数 i = 0 if l == 0: return 0 while i &lt; l and str[i] == ' ': i += 1 if str[i] == '+' or str[i] == '-': flag = 1 if str[i] == '+' else -1 i += 1 while i &lt; l: if '0' &lt;= str[i] &lt;= '9': is_valid = True ret = ret * 10 + int(str[i]) i += 1 else: break # 检查是否有效、是否负数 if not is_valid: return 0 elif flag == -1: ret = -ret # 检查是否溢出 if ret &gt; 2147483647: return 2147483647 elif ret &lt; -2147483648: return -2147483648 else: return ret]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7 - 颠倒整数]]></title>
    <url>%2F2018%2F04%2F09%2F7.%E9%A2%A0%E5%80%92%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 方法 看到题目，想到三个要注意的点： 负数的处理； 原数末尾为零时颠倒后要去掉； 如何检查32位整数的溢出。 解决： 给负数立个flag（没错就是立flag哈哈），然后绝对值化再处理，最后返回时给原本是负号的再负一下就行了； 判断判断就行，末尾有零的给他去掉； 笨方法就是直接判断有没有超过32位整数范围（-2147483648 ~ 2147483647），但是暂时还没想到不笨的方法（python的弱类型啊啊啊） 123456789101112131415161718192021222324252627282930class Solution: def reverse(self, x): """ :type x: int :rtype: int """ if -10 &lt; x &lt; 10: return x # 1.判断是否为负数 flag = False if x &lt; 0: x = -x flag = True # 2. 转化为字符串翻转 x = str(x)[::-1] # 3. 去掉多余的零 while x[0] == '0': x = x[1:] # 4. 转化为整数并判断溢出 x = int(x) if flag: x = -x if -2147483648 &lt; x &lt; 2147483647: return x else: return 0 一开始忽略了只有一位的情况，这种情况直接返回就好~~]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6 - Z字形转换]]></title>
    <url>%2F2018%2F04%2F09%2F6.Z%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目描述 看到题目的时候一脸懵逼，这啥呀，啥Z字形啊咋排的呀，怪不得这么多人给了unlike嚯嚯嚯。。。 事实证明，只有行数多了才能看出这个z，下图是直接用下标排的，一共5行。 思路： 一共N行时，total = 2*(N-1)个字符组成一个完整序列，即Z字的前两划； 每total个字符为一组，计算这一组中每个字符在第几行； 从第一行开始，把每一行的字符拼接起来返回。 123456789101112131415161718192021222324252627class Solution: def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1: return s l = len(s) total = 2 * (numRows - 1) tmp = [] ret = '' for k in range(numRows): tmp.append('') for i in range(l): idx = i % total if idx &gt;= numRows: idx = total - idx tmp[idx] += s[i] for j in range(numRows): ret += tmp[j] return ret 自测是没有问题的，提交了三次都提交不上去，我也只好unlike了( ･´ω`･ )恩恩好了好了AC了嚯嚯嚯]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5 - 最长回文子串]]></title>
    <url>%2F2018%2F04%2F08%2F5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 方法一思路： 分别以每个元素为中心，找出偶数长度的最长回文子串和奇数长度的最长回文子串 取奇偶中最长的一个 取所有元素为中心的最长的一个1234567891011121314151617181920212223242526272829303132class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ l = len(s) if l &lt;= 1: return s start = 0 max_len = 0 max_s = '' for i in range(1, l): low = i - 1 high = i while low&gt;=0 and high&lt;l and s[low]==s[high]: low -= 1 high += 1 if high-low+1 &gt; max_len: max_len = high-low+1 max_s = s[low+1 : high] low = i - 1 high = i + 1 while low&gt;=0 and high&lt;l and s[low]==s[high]: low -= 1 high += 1 if high-low+1 &gt; max_len: max_len = high-low+1 max_s = s[low+1 : high] return max_s 方法二：Manacher算法中期答辩精力有限，下次吧]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4 - 两个排序数组的中位数]]></title>
    <url>%2F2018%2F04%2F08%2F4.%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 方法一：先合并思路： 合并两个有序数组； 排序； 找中位数； but 这样的话原本的数组有不有序又有什么关系呢。。。 时间复杂度O(m+n) 12345678910111213141516class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ m = len(nums1) n = len(nums2) nums1.extend(nums2) nums1 = sorted( nums1 ) l = len(nums1) if l % 2 == 1: return nums1[l//2] else: return ( nums1[l//2-1] + nums1[l//2] ) / 2 方法二：二分查找 cr:两个有序数组的中位数（Hard） 不太懂，还是迷迷糊糊的，谁来救救我呀啊啊啊 思路：这里得提到中位数的性质，在有序的有限数集中，在中位数左边的数的个数与右边的相等。也就是说这个问题可以进一步转化为在nums1数组抽前i个数在nums2数组中抽前j个数，且i+j==halflen,(halflen=(m+n+1)/2)（在奇数情况下左边的数比右边多一个）。所以我们只要二分查找i，通过等式得到j=halflen−i，然后判断是否能满足中位数的条件。为了方便起见，同时减少运算次数，我们把数组size小的放到nums1，大的放到nums2，然后从nums1中查找i。进一步缩小查找范围？对于任意取的值i，我们能得到下面这张图中的关系。绿色的代表左边的数字，黄色的代表的是右边的数字。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ m = len(nums1) n = len(nums2) # 根据数组大小交换顺序，小的在前 # tmpn = 0 # tmparr = [] if m &gt; n: tmpn = m m = n n = tmpn tmparr = nums1 nums1 = nums2 nums2 = tmparr imin = 0 imax = m half_len = (m + n + 1)//2 # 二分查找i值 while imin &lt;= imax: i = (imin + imax) // 2 j = half_len - i if i &lt; m and nums2[j - 1] &gt; nums1[i] : imin = i + 1 elif i &gt; 0 and nums1[i - 1] &gt; nums2[j] : imax = i - 1 else: # 左边最大值 if not i: max_of_left = nums2[j-1] elif not j: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) # 如果总为奇数直接返回左边最大值 if (m + n)%2 == 1: return max_of_left # 右边最小值 if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2 return 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13 - 罗马数字转整数]]></title>
    <url>%2F2018%2F04%2F07%2F13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 罗马数字我觉得这位兄台的和百科差不多，又比百科美观，就借过来用用嘻嘻。 整数转罗马数字cr: leetcode 罗马数字与整数的转换算法 idea: 用“放在大数左边的数字只能使用一个”的特点来判断对当前字母是加还是减。 123456789101112131415161718192021class Solution: def intToRoman(self, num): """ :type num: int :rtype: str """ if num &lt;= 0: return '' ret = '' roman = ["M","CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"] arab = [1000, 900, 500, 400, 100,90, 50, 40, 10, 9, 5, 4, 1] for i in range(13): if num &gt; 0: if num &lt; arab[i]: continue while num &gt;= arab[i]: num -= arab[i] ret += roman[i] return ret]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12 - 整数转罗马数字]]></title>
    <url>%2F2018%2F04%2F07%2F12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述 恕我无知，拿到这题的第一件事就是上搜索引擎，看看罗马数字是咋回事。。。 罗马数字我觉得这位兄台的和百科差不多，又比百科美观，就借过来用用嘻嘻。 整数转罗马数字cr: leetcode 罗马数字与整数的转换算法 数字可以放在左边也可以放在右边，逻辑比较复杂。 如果都只能放在右边，那样就可以直接使用加法。如9表示为IX, 而如果表示为 VIIII,这样处理相加就OK. 可以使用组合数字来进行拆分，使程序能够实现连加的方法。 123456789101112131415161718192021class Solution: def intToRoman(self, num): """ :type num: int :rtype: str """ if num &lt;= 0: return '' ret = '' roman = ["M","CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"] arab = [1000, 900, 500, 400, 100,90, 50, 40, 10, 9, 5, 4, 1] for i in range(13): if num &gt; 0: if num &lt; arab[i]: continue while num &gt;= arab[i]: num -= arab[i] ret += roman[i] return ret]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9 - 回文数]]></title>
    <url>%2F2018%2F04%2F07%2F9.%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 思路一：直接颠倒数字12345678910111213141516class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False y = x r = 0 while x &gt; 0: r = r*10 + x%10 x = x // 10 return r == y 思路一：转换成字符串颠倒123456789101112class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False x = str(x) y = str(x)[::-1] return x == y 这道题是我做了，额，接近十题（惭愧惭愧）以来最最最easy的一题了hiahiahia✧｡٩(ˊᗜˋ)و✧*｡]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3 - 无重复字符的最长子串]]></title>
    <url>%2F2018%2F04%2F07%2F3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 自己的方法首先这个题目之前肯定是做过的，但是，我就知道我如此暴力肯定会超时o(╥﹏╥)o 思路： 字符串长度为0或者1直接返回0/1； 外层循环：从第一个字符开始，依次将每一个字符作为结果字符串的首字符； 内层循环：依次加字符，若是出现重复就将此重复字符作为首字符； 可行是可行，但就是超时了。。。 1234567891011121314151617181920212223242526272829class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ l = len(s) if l == 0 or l == 1: return l max_l = 1 max_r = '' for i in range(l): res = s[i] tmp_l = 1 tmp_r = res for j in range(i+1, l): if s[j] not in res: res += s[j] else: res = s[j] length = len(res) tmp_l = tmp_l if tmp_l &gt; length else length tmp_r = tmp_r if tmp_l &gt; length else res max_l = max_l if max_l &gt; tmp_l else tmp_l # max_r = max_r if max_l &gt; tmp_l else tmp_r # return max_r return max_l 别人的方法思路： 遍历字符串，过程中将出现过的字符存入字典，key为字符，value为字符下标 用maxLength保存遍历过程中找到的最大不重复子串的长度 用start保存最长子串的开始下标 如果字符已经出现在字典中，更新start的值 如果字符不在字典中，更新maxLength的值 1234567891011121314151617class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ start = maxLength = 0 usedChar = &#123;&#125; for i in range(l): if s[i] in usedChar and start &lt;= usedChar[s[i]]: start = usedChar[s[i]] + 1 else: maxLength = max(maxLength, i - start + 1) usedChar[s[i]] = i return maxLength 有了我，LeetCode的AC率恐怕。。。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2 - 两数相加]]></title>
    <url>%2F2018%2F04%2F06%2F2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目描述 第一次尝试【链表-&gt;数字-&gt;链表】思路一： 两个函数：链表-&gt;数字，数字-&gt;链表； 分别将两个加数链表化为数字相加； 将和化为链表返回。 思路二： 由于链表是高低位反向表示数字的，所以第一个结点是个位，第二个结点是十位… 同时遍历两个链表，每往后走一个结点就扩大十倍，同时在这里做加法； 步骤二直到两个链表遍历结束； 将和转化为链表返回。 写了思路一，思路二和思路一大同小异，不写了，懒(°ω°｣∠) 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ num1 = self.LinkedListToNum(l1) num2 = self.LinkedListToNum(l2) num = num1 + num2 return self.NumToLinkedList(num) def LinkedListToNum(self, head): num = 0 multiple = 1 #倍数 if head.val == 0 and head.next == None: return 0 while head.next is not None: num += head.val * multiple head = head.next multiple *= 10 num += head.val * multiple return num def NumToLinkedList(self, num): if num == 0: return ListNode(0) else: v = num % 10 num = num // 10 head = ListNode(v) curr = head while num != 0 : v = num % 10 num = num // 10 curr.next = ListNode(v) curr = curr.next return head debug 原因：链表转数字的时候判断有误，看到人家头结点val==0直接就一票否决返回0了。12if head.val == 0: return 0 解决：应该再判断是不是只有这一个结点啊喂，只有一个val为0的结点的话是0没错，但只有最后一位是0有何不可啊。12if head.val == 0 and head.next == None: return 0 第二次尝试【加法进位】那么，就按加法运算法则来一位一位地相加进位吧;emmmm..虽然思路是有的但是看到人家的只有几行就运过来了(〃ﾉωﾉ) 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ head = ListNode(0) curr = head carry = 0 # 进位 while l1 is not None or l2 is not None or carry != 0: num = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry carry = num // 10 curr.next = ListNode( num % 10 ) curr = curr.next l1 = l1.next if l1 else l1 l2 = l2.next if l2 else l2 return head.next 人家的coding和我第一个代码的思路大致一样，就是其中的实现比较简单，人家就是人家，人家永远比你聪明哈哈哈o(╥﹏╥)ocr: 两个用链表表示的数字相加 思路： 将链表整体转成str，再reverse reverse之后转成int相加，得到re re再次reverse之后，循环转成链表 12345678910111213141516171819202122232425262728# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ s1 = self.genS(l1) s2 = self.genS(l2) re = str(int(s1) + int(s2))[::-1] tmp = result = ListNode(int(re[0])) for i in range(1, len(re)): tmp.next = ListNode(int(re[i])) tmp = tmp.next return result def genS(self, li): s = '' while li: s += str(li.val) li = li.next return s[::-1] #新技能get：翻转字符串]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19 - 删除链表的倒数第N个节点]]></title>
    <url>%2F2018%2F04%2F06%2F19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述 方法思路一： 首先，要删除的是倒数第N个结点，单链表只能从前往后遍历，这样就要求知道链表一共有多少个结点； 知道链表一共有多少个结点的方法就是先遍历一遍； 这样的话要删除某个结点需要再跟着链表往后走一遍，去删除目标结点； 遍历两边，不妙不妙啊(ó﹏ò｡) 思路二： 使用两个指针，一快一慢； 快的比慢的快N个结点； 当快的到达尾部的时候，慢的正好指向目标结点的pre结点，只需要轻轻跳过它就Okey-dokey yo! 遍历一遍，妙哉妙哉(｡◕ˇ∀ˇ◕) 123456789101112131415161718192021222324252627282930313233343536373839# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ # 空链表：返回空链表 if head is None: return None # 不用删：返回原链表 if n == 0: return head # 快慢指针 fast = head slow = head # 快指针移动N个结点 for i in range(n): fast = fast.next # 删除第一个结点 if fast is None: return head.next # 快慢指针同时后移 while fast.next != None: fast = fast.next slow = slow.next # 删结点 slow.next = slow.next.next return head]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18 - 四数相加]]></title>
    <url>%2F2018%2F04%2F06%2F18.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目描述 我是怎么也想不出来时间复杂度小一点的方法，于是只好利用搜索引擎了。 cr: Quadratic algorithm for 4-SUM zhuli19901106 leetcode：4Sums(四个数相加的和) 解题思路 升序排序； 使用双层循环计算两数之和； 两指针在剩余元素中相向移动； 若四数之和等于target，加入结果序列； 跳过重复值。 123456789101112131415161718192021222324252627282930313233class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ nums = sorted(nums) l = len(nums) res = [] # i1,i2,i3,i4为四个指针 for i1 in range(0, l-3): for i2 in range(i1 + 1, l-2): i3 = i2 + 1 i4 = l - 1 # 循环结束条件为两指针相遇 while i3 &lt; i4: the_sum = nums[i1] + nums[i2] + nums[i3] + nums[i4] if the_sum &lt; target: i3 += 1 elif the_sum &gt; target: i4 -= 1 else: li = [ nums[i1], nums[i2], nums[i3], nums[i4] ] if li not in res: res.append(li) i3 += 1 return res debuglist赋值错误li是空数组，使用li[0]=xx这样赋值当然越界了，改用append。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20 - 有效的括号]]></title>
    <url>%2F2018%2F04%2F05%2F20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目描述 方法数据结构经典题，用栈完美解决。12345678910111213141516171819202122232425262728class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ if s is None: return false x = ['[','(','&#123;'] y = ["]",")","&#125;"] z = ["()","[]","&#123;&#125;"] stack = [] for char in s: if char in x: stack.append(char) elif char in y: if len(stack) == 0: return False else: temp = stack.pop(-1) + char if temp not in z: return False if len(stack) != 0: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21 - 合并两个有序链表]]></title>
    <url>%2F2018%2F04%2F05%2F21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述 老老实实翻开数据结构合并吧 判断链表是否为空，若链表为空则返回空链表； 创建一个新的空链表； 创建一个指针pre指向新链表头； 依次判断两个旧链表头结点val大小，pre指向小的那个，且将这个“小链表”的头指针删去； 其中一个旧链表全部接到新链表后，将另一个链表剩下的部分接到新链表。12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 is None and is None: return None else if l1 is None return l2 else if l2 is None: return l1 new_list = ListNode(0) pre = new_list while l1 is not None and l2 is not None: if l1.val &lt; l2.val: pre.next = l1 l1 = l1.next else pre.next = l2 l2 = l2.next pre = pre.next if l1 is not None: pre.next = l1 else: pre.next = l2 return new_list.next 递归12345678910111213class Solution: def mergeTwoLists(self, l1, l2): if not l1: return l2 elif not l2: return l1 else: if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17 - 电话号码的字母组合]]></title>
    <url>%2F2018%2F04%2F05%2F17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目描述 方法第一反应是全排列，但是怎么实现没有想到，久了没有刷过oj已经脑子生锈了。从别人那里借鉴的【深搜 + 递归】1234567891011121314151617181920212223242526class Solution: def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ begin = 0 #当前需要处理的digits的位置 path = '' #深搜路径 res = [] #返回结果 phone = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; self.deepSearch(digits, begin, path, res, phone) return res def deepSearch(self, digits, begin, path, res, phone): # 深搜触底，回溯 if len(path) == len(digits) : res.append(path) return # 遍历当前数字代表的所有字母 for char in phone[digits[begin]]: path += char # 从下一位开始到最后一位的组合情况 self.deepSearch(digits, begin + 1, path, res, phone) path = path[:-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1 - 两数之和 Two Sum]]></title>
    <url>%2F2018%2F04%2F05%2F1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述 1. 粗暴，【超时】：123456class Solution: def twoSum(self, nums, target): for i, a in enumerate(nums): for j, b in enumerate(nums): if i!=j and a+b == target: return (i,j) 2. 先过滤掉明显不可能的元素，再粗暴，下标会变啊喂！【错误】1234567class Solution: def twoSum(self, nums, target): nums = list( filter(lambda x: x &lt;= target, nums) ) for i, a in enumerate(nums): for j, b in enumerate(nums): if i!=j and a+b == target: return (i,j) 3.使用字典，hash查找速度666【通过】12345678class Solution: def twoSum(self, nums, target): tmp = &#123;&#125; for i, a in enumerate(nums): if target-a in tmp: return (tmp[target-a], i) else: tmp[a] = i]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小记]]></title>
    <url>%2F2018%2F04%2F04%2FPython%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[沉迷尤克里里电影和美丽花衣裳的程序媛要开始LeetCode了，在Java和Python之间义无反顾选择了Python，毕竟要竭尽全力减轻负担啊哈哈。快速自学记录一下语法特别之处吧╮(─▽─)╭cr: 廖雪峰的官方网站 编码ASCII（1个字节）：美国人儿那套；Unicode（2个字节）：把所有语言都统一到一套编码里，这样就不会再有乱码问题了（浪费空间）；UTF-8（可变长编码）：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 字符串普通str，以Unicode表示；前缀’r’，防止转义；前缀’b’，bytes类型，一个字节；encode()：如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes；decode()：如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes，需把bytes变为str；.decode(‘utf-8’, errors=’ignore’)：bytes中包含无法解码的字节会报错，这样忽略掉错误； dict和setdict和list和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 set和dict set和dict唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。 相同点：key必须是不可变对象。 函数定义函数如果有必要，可以先对参数的数据类型做检查；函数可以同时返回多个值，但其实就是一个tuple。空函数：pass语句 函数参数默认参数：一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！可变参数和关键字参数：123456```**kw```是关键字参数，kw接收的是一个dict。可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过```**kw```传入：```func(**&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;)```。使用\*args和```**kw```是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符\*，否则定义的将是位置参数。```def person(name, age, *, city, job): 尾递归在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。Python标准的解释器没有针对尾递归做优化。 高级特性切片 L[m:n]：取一个string、list或tuple的部分元素； s[::-1]：反转字符串 迭代... in```：只要是可迭代对象，无论有无下标，都可以迭代。判断一个对象是否可迭代对象可通过collections模块的Iterable类型判断：1```from collections import Iterable&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) 默认情况下，dict迭代的是key。如果要迭代value，可以用value in d.values()```，如果要同时迭代key和value，可以用```for k, v in d.items()```12实现下标循环：```for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):... print(i, value) 生成器generatorgenerator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。generator函数的“调用”实际返回一个generator对象。用for循环调用generator时拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。 迭代器iterator凡是可作用于for循环的对象都是Iterable类型；凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列（数据流）；集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。Python的for循环本质上就是通过不断调用next()函数实现的。 函数式编程高阶函数把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。map()函数：接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。reduce：把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算filter()：从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。排序：sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True) 匿名函数lambda，只能有一个表达式，不用写return，返回值就是该表达式的结果。不必担心函数名冲突。 偏函数当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 Python2与Python3迭代器range与xrangepython3中已经没有xrange函数了，其中的range已经是使用xrange的机制实现，所以直接用range就好啦。其它 字典对象的 dict.keys()、.items、dict.values() 方法都不再返回列表，而是以一个类似迭代器的 “view” 对象返回。而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。 高阶函数 map、filter、zip 返回的也都不是列表对象了。 Python2的迭代器必须实现 next 方法，而 Python3 改成了 next 数据类型 Python3去除了long类型，只有一种整型【int】，但其行为和python2的long一致； Python3新增了bytes类型，分别用 str 表示字符串，byte 表示字节序列，任何需要写入文本或者网络传输的数据都只接收字节序列，这就从源头上阻止了编码错误的问题。 作用域 变量引用顺序：当前作用域局部变量 -&gt; 外层作用域变量 -&gt; 当前模块中全局变量 -&gt; Python内置变量 globala. 在函数或其他局部作用域中要对全局变量做修改，则需要在局部使用global再次声明该全局变量。b. 不做修改时不必使用global声明。c. 由于全局性，函数执行完毕后不回销毁使用global修饰的变量。 nonlocala. Python3在嵌套函数中可以使用关键字nonlocal将变量声明为非局部；b. 适用于在一个局部作用域中的局部作用域使用，绑定一个外层（非全局）变量。 比较函数python2中可以使用函数cmp来比较，python3中这个函数也废掉了，那应该用啥咧~~]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue slot实例]]></title>
    <url>%2F2018%2F01%2F04%2FVue-slot%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[如何理解slot 如何理解Vue.js的组件中的slot? Jasin Yip的回答 slot 有点类似面向对象思想中的「多态」，比如要实现一个这么 Alert 组件： &lt;slot&gt; 就是外部调用时，标签中的内容。如果外部调用时没有提供内容的话，那么它就会使用自己默认提供的内容，非常方便。 使用组件：1234567891011121314&lt;div id="app"&gt; &lt;alert&gt;&lt;/alert&gt; &lt;alert type="success"&gt; &lt;strong&gt;Success!&lt;/strong&gt; Looks good to me! &lt;/alert&gt; &lt;alert type="warning"&gt; &lt;strong&gt;Warning!&lt;/strong&gt; Something not good. &lt;/alert&gt; &lt;alert type="error"&gt; &lt;strong&gt;Error!&lt;/strong&gt; Oooops... &lt;/alert&gt;&lt;/div&gt; 构造组件：12345678910111213141516171819202122&lt;style&gt; .Alert__close &#123; font-weight: bold; cursor: pointer; &#125; .Alert--Success &#123; color: green; &#125; .Alert--Warning &#123; color: #aa0; &#125; .Alert--Error &#123; color: red; &#125;&lt;/style&gt;&lt;template id="alert-template"&gt; &lt;div :class="alertClasses" v-show="show"&gt; &lt;slot&gt;&lt;strong&gt;Default!&lt;/strong&gt; Hello World~&lt;/slot&gt; &lt;span class="Alert__close" @click="show = false"&gt;x&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122Vue.component('alert', &#123; template: '#alert-template', props: ['type'], computed: &#123; alertClasses: function () &#123; return &#123; 'Alert--Success': this.type === 'success', 'Alert--Warning': this.type === 'warning', 'Alert--Error' : this.type === 'error' &#125; &#125; &#125;, data: function () &#123; return &#123; show: true &#125;; &#125;&#125;);new Vue(&#123; el: '#app'&#125;); 作用域插槽 作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的)可重用模板，来代替已经渲染好的元素。 slot-scope 用于 元素在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样。在父级中，具有特殊特性 slot-scope 的 &lt;template&gt;元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。 123&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt; 1234567891011121314151617181920Vue.component('child',&#123; template: '&lt;div class="child"&gt;\ &lt;slot text="hello from child"&gt;&lt;/slot&gt;\ &lt;/div&gt;'&#125;)Vue.component('parent', &#123; template: '&lt;div class="parent"&gt;\ &lt;child&gt;\ &lt;template slot-scope="props"&gt;\ &lt;span&gt;hello from parent&lt;/span&gt;\ &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;\ &lt;/template&gt;\ &lt;/child&gt;\ &lt;/div&gt;'&#125;)new Vue(&#123; el: "#app"&#125;) 渲染结果： slot-scope 可用于任意元素作用域插槽更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项： 12345678910&lt;div id="app"&gt; &lt;my-awesome-list :item="items"&gt; &lt;li slot="item" slot-scope="props" class="my-fancy-item"&gt; &#123;&#123; props.text &#125;&#125; &lt;/li&gt; &lt;/my-awesome-list&gt; &lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334Vue.component('my-awesome-list',&#123; template: '&lt;ul&gt;\ &lt;slot name="item"\ v-for="item in items"\ :text="item.text"&gt;\ 备用内容\ &lt;/slot&gt;\ &lt;/ul&gt;', data: function () &#123; return &#123; items: [ &#123;text: "111"&#125;, &#123;text: "222"&#125;, &#123;text: "333"&#125; ] &#125; &#125;&#125;)new Vue(&#123; el: "#app", data: &#123; items: [ // &#123;text: "111"&#125;, // &#123;text: "222"&#125;, // &#123;text: "333"&#125; ] &#125;, methods: &#123; incrementTotal : function () &#123; this.total += 1 &#125; &#125;&#125;) 渲染结果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC, MVP, MVVM]]></title>
    <url>%2F2017%2F12%2F30%2FMVC-MVP-MVVM%2F</url>
    <content type="text"><![CDATA[MVC一、什么是MVC开发模式M【Model】：模型包含应用程序的业务数据和业务逻辑，主要包括业务逻辑模型（包含应用的业务操作，比如订单的添加或者修改等。）和业务数据模型（存放业务数据，比如订单信息、用户信息等​）。由model提供视图的显示数据，同时一个Model可以为多个视图提供业务数据，因此Model可以提高业务的可重用性。 V【View】：视图即与用户交互的界面，可以给用户显示业务逻辑数据，同时可以接收用户输入的数据。视图层不对数据进行任何的业务逻辑处理。 C【Controller】：控制器协调模型与视图，根据视图接收的用户请求来决定调用哪个Model模型来处理业务，同时将处理好的数据传给对应的视图来为用户做出应答。 二、MVC处理流程：用户通过View将参数提交到Controller；Controller调用对应的Model处理数据；Controller将处理好的数据输出到对应的View给用户。 三、使用MVC的优点低耦合性：在MVC模式中，模型和视图是解耦的，模型不会依赖于视图，而视图也仅仅是从模型中获取需要展示的数据，并不会与模型的逻辑处理相关联。更低的开发成本：由于MVC模式帮我们清楚的划分了各部分的职责，就可以让程序员各司其职，Java程序员只关心业务逻辑的实现，也就是模型部分；而界面程序员只关心页面展示，也就是视图部分即可。更好的可维护性：MVC模式划分出明晰的模型和视图部分，并使其解耦，在软件需求发生变更的时候，就可以各自独立的改变而不会相互影响，使得程序更容易维护和扩展。 MVP切断的View和Model的联系，让View只和Presenter（原Controller）交互，减少在需求变化中需要维护的对象的数量。 MVVMViewModel大致上就是MVP的Presenter和MVC的Controller了，而View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。为了用一种统一的集中的方式实现频繁需要被实现的数据更新问题。 比起MVP，MVVM不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。]]></content>
      <categories>
        <category>Programming ideas</category>
      </categories>
  </entry>
</search>
