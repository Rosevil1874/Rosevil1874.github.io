<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA['合并两个有序链表']]></title>
    <url>%2F2018%2F04%2F05%2F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[老老实实翻开数据结构合并吧 判断链表是否为空，若链表为空则返回空链表； 创建一个新的空链表； 创建一个指针pre指向新链表头； 依次判断两个旧链表头结点val大小，pre指向小的那个，且将这个“小链表”的头指针删去； 其中一个旧链表全部接到新链表后，将另一个链表剩下的部分接到新链表。12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; if l1 is None and is None: return None else if l1 is None return l2 else if l2 is None: return l1 new_list = ListNode(0) pre = new_list while l1 is not None and l2 is not None: if l1.val &lt; l2.val: pre.next = l1 l1 = l1.next else pre.next = l2 l2 = l2.next pre = pre.next if l1 is not None: pre.next = l1 else: pre.next = l2 return new_list.next 递归12345678910111213class Solution: def mergeTwoLists(self, l1, l2): if not l1: return l2 elif not l2: return l1 else: if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电话号码的字母组合']]></title>
    <url>%2F2018%2F04%2F05%2F%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[第一反应是全排列，但是怎么实现没有想到，久了没有刷过oj已经脑子生锈了。从别人那里借鉴的【深搜 + 递归】1234567891011121314151617181920212223242526class Solution: def letterCombinations(self, digits): &quot;&quot;&quot; :type digits: str :rtype: List[str] &quot;&quot;&quot; begin = 0 #当前需要处理的digits的位置 path = &apos;&apos; #深搜路径 res = [] #返回结果 phone = &#123;&apos;2&apos;:&apos;abc&apos;,&apos;3&apos;:&apos;def&apos;,&apos;4&apos;:&apos;ghi&apos;,&apos;5&apos;:&apos;jkl&apos;,&apos;6&apos;:&apos;mno&apos;,&apos;7&apos;:&apos;pqrs&apos;,&apos;8&apos;:&apos;tuv&apos;,&apos;9&apos;:&apos;wxyz&apos;&#125; self.deepSearch(digits, begin, path, res, phone) return res def deepSearch(self, digits, begin, path, res, phone): # 深搜触底，回溯 if len(path) == len(digits) : res.append(path) return # 遍历当前数字代表的所有字母 for char in phone[digits[begin]]: path += char # 从下一位开始到最后一位的组合情况 self.deepSearch(digits, begin + 1, path, res, phone) path = path[:-1]]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. 两数之和 Two Sum]]></title>
    <url>%2F2018%2F04%2F05%2FSum%2F</url>
    <content type="text"><![CDATA[1. 粗暴，【超时】：123456class Solution: def twoSum(self, nums, target): for i, a in enumerate(nums): for j, b in enumerate(nums): if i!=j and a+b == target: return (i,j) 2. 先过滤掉明显不可能的元素，再粗暴，下标会变啊喂！【错误】1234567class Solution: def twoSum(self, nums, target): nums = list( filter(lambda x: x &lt;= target, nums) ) for i, a in enumerate(nums): for j, b in enumerate(nums): if i!=j and a+b == target: return (i,j) 3.使用字典，hash查找速度666【通过】12345678class Solution: def twoSum(self, nums, target): tmp = &#123;&#125; for i, a in enumerate(nums): if target-a in tmp: return (tmp[target-a], i) else: tmp[a] = i]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python小记]]></title>
    <url>%2F2018%2F04%2F04%2FPython%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[沉迷尤克里里电影和美丽花衣裳的程序媛要开始LeetCode了，在Java和Python之间义无反顾选择了Python，毕竟要竭尽全力减轻负担啊哈哈。快速自学记录一下语法特别之处吧╮(─▽─)╭cr: 廖雪峰的官方网站 编码ASCII（1个字节）：美国人儿那套；Unicode（2个字节）：把所有语言都统一到一套编码里，这样就不会再有乱码问题了（浪费空间）；UTF-8（可变长编码）：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 字符串普通str，以Unicode表示；前缀’r’，防止转义；前缀’b’，bytes类型，一个字节；encode()：如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes；decode()：如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes，需把bytes变为str；.decode(‘utf-8’, errors=’ignore’)：bytes中包含无法解码的字节会报错，这样忽略掉错误； dict和setdict和list和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 set和dict set和dict唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。 相同点：key必须是不可变对象。 函数定义函数：如果有必要，可以先对参数的数据类型做检查；函数可以同时返回多个值，但其实就是一个tuple。空函数：pass语句 函数参数默认参数：一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！可变参数和关键字参数：123456```**kw```是关键字参数，kw接收的是一个dict。可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过```**kw```传入：```func(**&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;)```。使用\*args和```**kw```是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符\*，否则定义的将是位置参数。```def person(name, age, *, city, job): 尾递归在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。Python标准的解释器没有针对尾递归做优化。 高级特性切片 L[m:n]：取一个string、list或tuple的部分元素；迭代... in```：只要是可迭代对象，无论有无下标，都可以迭代。判断一个对象是否可迭代对象可通过collections模块的Iterable类型判断：1```from collections import Iterable&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) 默认情况下，dict迭代的是key。如果要迭代value，可以用value in d.values()```，如果要同时迭代key和value，可以用```for k, v in d.items()```12实现下标循环：```for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):... print(i, value) 生成器generatorgenerator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。generator函数的“调用”实际返回一个generator对象。用for循环调用generator时拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。 迭代器iterator凡是可作用于for循环的对象都是Iterable类型；凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列（数据流）；集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。Python的for循环本质上就是通过不断调用next()函数实现的。 函数式编程高阶函数：把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。map()函数：接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。reduce：把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算filter()：从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。排序：sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)匿名函数：lambda，只能有一个表达式，不用写return，返回值就是该表达式的结果。不必担心函数名冲突。偏函数：当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue slot实例]]></title>
    <url>%2F2018%2F01%2F04%2FVue-slot%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[如何理解slot 如何理解Vue.js的组件中的slot? Jasin Yip的回答 slot 有点类似面向对象思想中的「多态」，比如要实现一个这么 Alert 组件： &lt;slot&gt; 就是外部调用时，标签中的内容。如果外部调用时没有提供内容的话，那么它就会使用自己默认提供的内容，非常方便。 使用组件：1234567891011121314&lt;div id="app"&gt; &lt;alert&gt;&lt;/alert&gt; &lt;alert type="success"&gt; &lt;strong&gt;Success!&lt;/strong&gt; Looks good to me! &lt;/alert&gt; &lt;alert type="warning"&gt; &lt;strong&gt;Warning!&lt;/strong&gt; Something not good. &lt;/alert&gt; &lt;alert type="error"&gt; &lt;strong&gt;Error!&lt;/strong&gt; Oooops... &lt;/alert&gt;&lt;/div&gt; 构造组件：12345678910111213141516171819202122&lt;style&gt; .Alert__close &#123; font-weight: bold; cursor: pointer; &#125; .Alert--Success &#123; color: green; &#125; .Alert--Warning &#123; color: #aa0; &#125; .Alert--Error &#123; color: red; &#125;&lt;/style&gt;&lt;template id="alert-template"&gt; &lt;div :class="alertClasses" v-show="show"&gt; &lt;slot&gt;&lt;strong&gt;Default!&lt;/strong&gt; Hello World~&lt;/slot&gt; &lt;span class="Alert__close" @click="show = false"&gt;x&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122Vue.component('alert', &#123; template: '#alert-template', props: ['type'], computed: &#123; alertClasses: function () &#123; return &#123; 'Alert--Success': this.type === 'success', 'Alert--Warning': this.type === 'warning', 'Alert--Error' : this.type === 'error' &#125; &#125; &#125;, data: function () &#123; return &#123; show: true &#125;; &#125;&#125;);new Vue(&#123; el: '#app'&#125;); 作用域插槽 作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的)可重用模板，来代替已经渲染好的元素。 slot-scope 用于 元素在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样。在父级中，具有特殊特性 slot-scope 的 &lt;template&gt;元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。 123&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt; 1234567891011121314151617181920Vue.component('child',&#123; template: '&lt;div class="child"&gt;\ &lt;slot text="hello from child"&gt;&lt;/slot&gt;\ &lt;/div&gt;'&#125;)Vue.component('parent', &#123; template: '&lt;div class="parent"&gt;\ &lt;child&gt;\ &lt;template slot-scope="props"&gt;\ &lt;span&gt;hello from parent&lt;/span&gt;\ &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;\ &lt;/template&gt;\ &lt;/child&gt;\ &lt;/div&gt;'&#125;)new Vue(&#123; el: "#app"&#125;) 渲染结果： slot-scope 可用于任意元素作用域插槽更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项： 12345678910&lt;div id="app"&gt; &lt;my-awesome-list :item="items"&gt; &lt;li slot="item" slot-scope="props" class="my-fancy-item"&gt; &#123;&#123; props.text &#125;&#125; &lt;/li&gt; &lt;/my-awesome-list&gt; &lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334Vue.component('my-awesome-list',&#123; template: '&lt;ul&gt;\ &lt;slot name="item"\ v-for="item in items"\ :text="item.text"&gt;\ 备用内容\ &lt;/slot&gt;\ &lt;/ul&gt;', data: function () &#123; return &#123; items: [ &#123;text: "111"&#125;, &#123;text: "222"&#125;, &#123;text: "333"&#125; ] &#125; &#125;&#125;)new Vue(&#123; el: "#app", data: &#123; items: [ // &#123;text: "111"&#125;, // &#123;text: "222"&#125;, // &#123;text: "333"&#125; ] &#125;, methods: &#123; incrementTotal : function () &#123; this.total += 1 &#125; &#125;&#125;) 渲染结果：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC, MVP, MVVM]]></title>
    <url>%2F2017%2F12%2F30%2FMVC-MVP-MVVM%2F</url>
    <content type="text"><![CDATA[MVC一、什么是MVC开发模式M【Model】：模型包含应用程序的业务数据和业务逻辑，主要包括业务逻辑模型（包含应用的业务操作，比如订单的添加或者修改等。）和业务数据模型（存放业务数据，比如订单信息、用户信息等​）。由model提供视图的显示数据，同时一个Model可以为多个视图提供业务数据，因此Model可以提高业务的可重用性。 V【View】：视图即与用户交互的界面，可以给用户显示业务逻辑数据，同时可以接收用户输入的数据。视图层不对数据进行任何的业务逻辑处理。 C【Controller】：控制器协调模型与视图，根据视图接收的用户请求来决定调用哪个Model模型来处理业务，同时将处理好的数据传给对应的视图来为用户做出应答。 二、MVC处理流程：用户通过View将参数提交到Controller；Controller调用对应的Model处理数据；Controller将处理好的数据输出到对应的View给用户。 三、使用MVC的优点低耦合性：在MVC模式中，模型和视图是解耦的，模型不会依赖于视图，而视图也仅仅是从模型中获取需要展示的数据，并不会与模型的逻辑处理相关联。更低的开发成本：由于MVC模式帮我们清楚的划分了各部分的职责，就可以让程序员各司其职，Java程序员只关心业务逻辑的实现，也就是模型部分；而界面程序员只关心页面展示，也就是视图部分即可。更好的可维护性：MVC模式划分出明晰的模型和视图部分，并使其解耦，在软件需求发生变更的时候，就可以各自独立的改变而不会相互影响，使得程序更容易维护和扩展。 MVP切断的View和Model的联系，让View只和Presenter（原Controller）交互，减少在需求变化中需要维护的对象的数量。 MVVMViewModel大致上就是MVP的Presenter和MVC的Controller了，而View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。为了用一种统一的集中的方式实现频繁需要被实现的数据更新问题。 比起MVP，MVVM不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。]]></content>
      <categories>
        <category>Programming ideas</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Goodbye 2017]]></title>
    <url>%2F2017%2F12%2F30%2FGoodbye-2017%2F</url>
    <content type="text"><![CDATA[把今年的愿望，再许一遍。 20172017倒数第二天，我这一年都做了些什么。 大三下03-21 加入KEEP，开始一点点运动 :muscle:06-18 骑行10公里，参加毕业音乐会06-24 广州参观实习，火车通宵、各种夜宵、小蛮腰—– 上半年可以说是一片空白了 :broken_heart: 大四上08-15 陪汪大铮在长沙晃哒了一周，炒鸡开心，也比较遗憾自己有些心不在焉(智障障 :zzz: )08-22 准备找工作每天投简历参加笔试，后来准备保研复试—– 南大复试，Java机试0AC，一个人吃了一笼鸡汁灌汤包09-23 复旦复试，和燕子去了上海，鲜肉月饼啧啧啧10-01 开始练字10-02 使用WordPress搭建了第一个自己的博客，立即闲置 :joy:10-29 去46LiveHouse看了谢春花小姐姐的演出11-04 开始家教，给师大大二的小男生上算法，C++，计组11-18 开始“融城计划”，和兰东旭小哥哥一起去给小朋友上音乐课12-23 燕子考研，不用再去接她回宿舍啦12-30 使用GitPage+Hexo搭建了自己的第二个博客，希望能用起来—– 退了天鹅湖的票买了一把小U，开始学习吧—– 粗略学习了python，使用其进行中文微博情感分析 2018找不到我的2017新年愿望了，估计一项也没有实现，现在的2018新年愿望很有可能和去年的是一样的(ー_ー)!! 改变自己最大的心理问题，不要害怕被人看到自己的努力，别人看不到你努力自己同样会努力，你这样会被那些开心积极乐观奋斗的人超越得远远的。不管学习还是生活方面的。 运动 :point_right: 你的身体不允许懒惰 饮食 :point_right: 甜食少一点，多巴胺多一点 作息 :point_right: 早起办到了，还要早睡 小U :point_right: 一年很长，能学会的 练字 :point_right: 慢慢来吧，坚持 阅读 :point_right: 跳出舒适区 英语 :point_right: 单词，歌曲，阅读，发声 生活 :sunny: 你和你的家人朋友才是最重要的 你有那么多的收藏夹叫做better me，一定可以做到的呀，慢慢来。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>wishes</tag>
      </tags>
  </entry>
</search>
